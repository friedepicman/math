<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mock AIME Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1 {
      text-align: center;
      color: #004488;
    }
    select, button {
      font-size: 16px;
      padding: 8px;
      margin: 10px 5px;
    }
    .problem {
      background: white;
      padding: 20px;
      margin: 15px 0;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.05);
    }
    .answer {
      margin-top: 10px;
    }
    input[type="text"] {
      padding: 6px;
      font-size: 16px;
      width: 100px;
    }
    .stats {
      margin: 10px 0;
      font-size: 15px;
      color: #333;
      white-space: pre-wrap;
    }
    .result {
      display: inline-block;
      margin-left: 10px;
      font-size: 18px;
    }
    .correct {
      color: green;
    }
    .incorrect {
      color: red;
    }
    .difficulty-indicator {
      display: inline-block;
      background: #e0e0e0;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 10px;
      color: #666;
    }
    #summary {
      margin: 15px 0;
      font-size: 16px;
      font-weight: bold;
      color: #004488;
      white-space: pre-wrap;
    }
    label {
      cursor: pointer;
    }
    .mode-toggle {
      margin: 10px 0 20px 0;
    }
  </style>

  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      options: {
        ignoreHtmlClass: 'no-mathjax',
        processHtmlClass: 'mathjax-process'
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <h1>Mock AIME Generator</h1>

  <div class="mode-toggle">
    <label>
      <input type="checkbox" id="expandedDbCheckbox" />
      Use Expanded Problem Database
    </label>
    &nbsp;&nbsp;&nbsp;
    <label>
      <input type="checkbox" id="fullDbCheckbox" />
      Use Full Database (No Automatic Answer Check)
    </label>
  </div>

  <label for="difficulty">Select Difficulty Level:</label>
  <select id="difficulty">
    <option value="1">1 - Easiest</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5" selected>5</option>
    <option value="6">6</option>
    <option value="7">7</option>
    <option value="8">8</option>
    <option value="9">9</option>
    <option value="10">10 - Hardest</option>
  </select>

  <button onclick="generateMock()">Generate Mock</button>
  <button onclick="checkAnswers()">Check Answers</button>

  <div id="instructions" style="margin: 20px 0; font-size: 15px; color: #333; white-space: pre-wrap;"></div>
  <div class="stats" id="stats"></div>
  <div id="summary"></div>
  <div id="problems"></div>

  <script>
    // Ensure only one checkbox can be selected at a time
    const expandedCheckbox = document.getElementById('expandedDbCheckbox');
    const fullCheckbox = document.getElementById('fullDbCheckbox');
    expandedCheckbox.addEventListener('change', () => {
      if (expandedCheckbox.checked) fullCheckbox.checked = false;
    });
    fullCheckbox.addEventListener('change', () => {
      if (fullCheckbox.checked) expandedCheckbox.checked = false;
    });

    const difficultyTemplate = {
      "1": { "2.5": 1, "3.0": 3, "3.5": 3, "4.0": 3, "4.5": 2, "5.0": 2, "5.5": 1, "6.0": 0, "6.5": 0, "7.0": 0, "7.5": 0, "8.0": 0 },
      "2": { "2.5": 1, "3.0": 3, "3.5": 3, "4.0": 2, "4.5": 2, "5.0": 1, "5.5": 1, "6.0": 1, "6.5": 1, "7.0": 0, "7.5": 0, "8.0": 0 },
      "3": { "2.5": 0, "3.0": 3, "3.5": 2, "4.0": 3, "4.5": 2, "5.0": 1, "5.5": 1, "6.0": 1, "6.5": 2, "7.0": 0, "7.5": 0, "8.0": 0 },
      "4": { "2.5": 0, "3.0": 3, "3.5": 2, "4.0": 2, "4.5": 2, "5.0": 2, "5.5": 1, "6.0": 1, "6.5": 1, "7.0": 1, "7.5": 0, "8.0": 0 },
      "5": { "2.5": 0, "3.0": 2, "3.5": 3, "4.0": 2, "4.5": 1, "5.0": 1, "5.5": 1, "6.0": 2, "6.5": 2, "7.0": 1, "7.5": 0, "8.0": 0 },
      "6": { "2.5": 0, "3.0": 2, "3.5": 2, "4.0": 2, "4.5": 2, "5.0": 1, "5.5": 2, "6.0": 1, "6.5": 1, "7.0": 2, "7.5": 0, "8.0": 0 },
      "7": { "2.5": 0, "3.0": 2, "3.5": 2, "4.0": 1, "4.5": 1, "5.0": 2, "5.5": 2, "6.0": 1, "6.5": 1, "7.0": 2, "7.5": 1, "8.0": 0 },
      "8": { "2.5": 0, "3.0": 1, "3.5": 2, "4.0": 2, "4.5": 1, "5.0": 2, "5.5": 2, "6.0": 2, "6.5": 1, "7.0": 1, "7.5": 1, "8.0": 0 },
      "9": { "2.5": 0, "3.0": 1, "3.5": 1, "4.0": 2, "4.5": 1, "5.0": 2, "5.5": 2, "6.0": 1, "6.5": 2, "7.0": 1, "7.5": 2, "8.0": 0 },
      "10": { "2.5": 0, "3.0": 0, "3.5": 1, "4.0": 2, "4.5": 2, "5.0": 1, "5.5": 2, "6.0": 2, "6.5": 1, "7.0": 1, "7.5": 2, "8.0": 1 }
    };

    let allProblems = [];
    let chosenProblems = [];

    // Load your JSON with aime_answer keys included
    fetch('with_aime_answers.json')
      .then(res => res.json())
      .then(data => {
        allProblems = data;
        console.log("Loaded", allProblems.length, "problems.");
      });

    function bucketizeFine() {
      const buckets = {};
      for (let d = 2.5; d <= 8; d += 0.5) {
        buckets[d.toFixed(1)] = [];
      }

      // Filter by answer_type positive integer <= 1000 for normal and expanded DB modes
      const useExpanded = expandedCheckbox.checked;

      for (const p of allProblems) {
        let d = parseFloat(p.difficulty);
        const answerType = p.answer_type?.toLowerCase().trim();

        if (isNaN(d)) continue;

        // For expanded mode, allow problems with aime_answer key
        if (useExpanded) {
          if (!("aime_answer" in p)) continue;
        } else {
          if (answerType !== "positive integer <= 1000") continue;
        }

        const key = (Math.round(d * 2) / 2).toFixed(1);
        if (buckets[key]) {
          buckets[key].push(p);
        }
      }

      return buckets;
    }

    function sample(arr, n) {
      const copy = [...arr];
      const result = [];
      while (result.length < n && copy.length > 0) {
        const idx = Math.floor(Math.random() * copy.length);
        result.push(copy.splice(idx, 1)[0]);
      }
      return result;
    }

    async function generateMock() {
      const useExpanded = expandedCheckbox.checked;
      const useFull = fullCheckbox.checked;
      const level = document.getElementById("difficulty").value;

      // Clear instructions and summary
      document.getElementById("instructions").textContent = "";
      document.getElementById("summary").textContent = "";

      if (useExpanded) {
        document.getElementById("instructions").textContent =
`Note: Problems in the expanded database may include answers not limited to positive integers from 0 to 999.
Examples of such answers include fractions (e.g., \\( \\frac{3}{5} \\)), powers (e.g., \\( 2^{10} \\)), or expressions involving sums of components.
Please enter your answer as the sum of the components modulo 1000.
For example:
- \\( \\frac{3}{5} \\) → enter 8
- \\( 2^{10} / 3 \\) → enter 2 + 10 + 3 = 15
- \\( 7 \\) → enter 7
`;
      }

      if (useFull) {
        // In full DB mode, no difficulty filtering
        // So bucketizeFine is not needed for problem selection
        // Just pick 15 random problems from full database
        chosenProblems = [];
        const copyAll = [...allProblems];
        while (chosenProblems.length < 15 && copyAll.length > 0) {
          const idx = Math.floor(Math.random() * copyAll.length);
          chosenProblems.push(copyAll.splice(idx, 1)[0]);
        }
      } else {
        // Normal and expanded mode: bucketize and sample
        const plan = difficultyTemplate[level];
        const buckets = bucketizeFine();

        // Show stats
        let statText = "Available / Needed problems:\n";
        for (const [diff, countNeeded] of Object.entries(plan)) {
          const available = buckets[diff]?.length || 0;
          statText += `  (${diff}): ${available} / ${countNeeded}\n`;
        }
        document.getElementById("stats").textContent = statText;

        // Check for shortage
        for (const [diff, countNeeded] of Object.entries(plan)) {
          if ((buckets[diff]?.length || 0) < countNeeded) {
            document.getElementById("problems").innerHTML =
              `<p style="color:red;"><strong>Not enough problems in bucket ${diff} to generate mock.</strong></p>`;
            return;
          }
        }

        chosenProblems = [];
        for (const [diff, count] of Object.entries(plan)) {
          chosenProblems.push(...sample(buckets[diff], count));
        }
      }

      const container = document.getElementById("problems");
      container.innerHTML = "";

      chosenProblems.forEach((p, i) => {
        const div = document.createElement("div");
        div.className = "problem mathjax-process";

        if (useFull) {
          // Full DB mode: checkbox "I was correct" and no answer inputs
          div.innerHTML = `
            <strong>Problem ${i + 1}:</strong>
            <span class="difficulty-indicator">Difficulty: ${parseFloat(p.difficulty).toFixed(1)}</span>
            <p>${p.text}</p>
            <div>
              <label><input type="checkbox" class="override" data-index="${i}" /> I was correct</label>
            </div>
            <div><strong>Source:</strong> ${p.source || "Unknown"}</div>
            <div><a href="${p.link}" target="_blank">[View Discussion]</a></div>
            <span class="result" id="result-${i}"></span>
          `;
        } else {
          // Normal or expanded mode: text input answer box
          div.innerHTML = `
            <strong>Problem ${i + 1}:</strong>
            <span class="difficulty-indicator">Difficulty: ${parseFloat(p.difficulty).toFixed(1)}</span>
            <p>${p.text}</p>
            <div class="answer">Answer: <input type="text" maxlength="3" data-index="${i}" /></div>
            <div><a href="${p.link}" target="_blank">[View Discussion]</a></div>
            <span class="result" id="result-${i}"></span>
          `;
        }

        container.appendChild(div);
      });

      // Typeset MathJax for rendered problems
      if (window.MathJax) {
        try {
          await MathJax.typesetPromise();
        } catch (err) {
          console.error('MathJax typeset failed: ', err);
        }
      }
    }

    function checkAnswers() {
      let correctCount = 0;
      let summaryLines = [];

      chosenProblems.forEach((p, i) => {
        const overrideCheckbox = document.querySelector(`input.override[data-index="${i}"]`);
        const userOverride = overrideCheckbox?.checked || false;
        const resultSpan = document.getElementById(`result-${i}`);

        if (userOverride) {
          // User says they were correct (override)
          resultSpan.textContent = "✔️ (overridden)";
          resultSpan.className = "result correct";
          correctCount++;
          summaryLines.push(`Problem ${i + 1}: ✔️ (overridden)`);
          return;
        }

        const answerInput = document.querySelector(`input[data-index="${i}"]:not(.override)`);

        if (answerInput) {
          const userAnswer = answerInput.value.trim();

          if ("aime_answer" in p) {
            const expected = String(p.aime_answer % 1000);
            const correct = userAnswer === expected;
            resultSpan.textContent = correct ? "✔️" : "❌";
            resultSpan.className = "result " + (correct ? "correct" : "incorrect");
            if (correct) correctCount++;
            summaryLines.push(`Problem ${i + 1}: ${correct ? "✔️" : "❌"}`);
          } else if ("answer" in p) {
            const correct = userAnswer === String(p.answer);
            resultSpan.textContent = correct ? "✔️" : "❌";
            resultSpan.className = "result " + (correct ? "correct" : "incorrect");
            if (correct) correctCount++;
            summaryLines.push(`Problem ${i + 1}: ${correct ? "✔️" : "❌"}`);
          } else {
            resultSpan.textContent = "";
            summaryLines.push(`Problem ${i + 1}: No answer available`);
          }
        } else {
          // Full DB mode and no override — mark as unchecked
          resultSpan.textContent = "";
          summaryLines.push(`Problem ${i + 1}: No answer checked`);
        }
      });

      const summaryText = `Score: ${correctCount} / ${chosenProblems.length}\n` + summaryLines.join("  ");
      document.getElementById("summary").textContent = summaryText;
    }
  </script>
</body>
</html>
